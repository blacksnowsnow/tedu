seucre 安全

步骤一：修改用户zhangsan的账户属性，设置为2019-12-31日失效（禁止登录）
1）正常情况下，未过期的账号可以正常登录，使用chage可以修改账户有效期。
chage命令的语法格式：
chage –l    账户名称                                //查看账户信息
chage –E 时间 账户名称                            //修改账户有效期
# chage -E 2015-05-15 zhangsan

4）定义默认有效期（扩展知识）
/etc/login.defs这个配置文件，决定了账户密码的默认有效期。
[root@svr5 ~]# cat /etc/login.defs
PASS_MAX_DAYS    99999                        //密码最长有效期
PASS_MIN_DAYS    0                            //密码最短有效期
PASS_MIN_LEN    5                            //密码最短长度
PASS_WARN_AGE    7                            //密码过期前几天提示警告信息
UID_MIN                  1000                //UID最小值
UID_MAX                 60000                //UID最大值

步骤二：临时锁定用户lisi的账户，使其无法登录，验证效果后解除锁定
1）锁定用户账号
使用passwd或usermod命令将用户lisi的账户锁定。
[root@svr5 ~]# passwd -l lisi                           //锁定用户账号lock
锁定用户 lisi 的密码。
passwd: 操作成功
[root@svr5 ~]# passwd -S lisi                          //查看状态status
lisi LK 2018-02-22 0 99999 7 -1 (密码已被锁定。)
2）解除对用户lisi的锁定
[root@svr5 ~]# passwd -u lisi                           //解锁用户账号
解锁用户 lisi 的密码 。
passwd: 操作成功
[root@svr5 ~]# passwd -S lisi 

//清空用户口令
[root@svr5 ~]# passwd -d kate   
                       
步骤三：修改tty登录的提示信息，隐藏系统版本
1）账户在登录Linux系统时，默认会显示登陆信息（包括操作系统内核信息）
/etc/issue这个配置文件里保存的就是这些登陆信息，修改该文件防止内核信息泄露。
[root@svr5 ~]# cat /etc/issue                              //确认原始文件
Red Hat Enterprise Linux Server release 6.5 (Santiago)
Kernel \r on an \m
[root@svr5 ~]# cp /etc/issue /etc/issue.origin              //备份文件
[root@svr5 ~]# vim /etc/issue           

步骤四：锁定文件/etc/resolv.conf、/etc/hosts
1）语法格式：
# chattr +i  文件名                    //锁定文件（无法修改、删除等）
# chattr -i  文件名                    //解锁文件
# chattr +a  文件名                    //锁定后文件仅可追加
# chattr -a  文件名                    //解锁文件
# lsattr 文件名                        //查看文件特殊属性
2) 使用+i锁定文件，使用lsattr查看属性

步骤一：使用su命令临时切换账户身份，并以root执行命令
su(Substitute User)命令可以快速切换账户身份，普通用户切换账户身份时需要输入密码，root使用su命令切换任何身份都不需要密码，如法格式如下：
# su –  [账户名称]
# su -  [账户名称]  -c '命令'  
1)从普通用户切换为root账户身份(如果没有普通账户则需要先创建)
[jacob@svr5 ~]# whoami
jacob

2)以普通身份创建目录(如果没有普通账户则需要先创建)，以root身份重启服务
[root@svr5 ~]# su - tom  -c "mkdir /home/tom/test"        //管理员切换普通用户
[root@svr5 ~]# ll -d  /home/tom/test
[tom@svr5 ~]# su - -c "systemctl restart sshd"            //以管理员重启服务
密码：

步骤二：允许softadm管理系统服务的权限
1）修改/etc/sudoers配置
修改/etc/sudoers可以直接使用vim编辑该文件，或使用visudo命令修改该文件。
为softadm授予相关脚本的执行权限，允许通过systemctl工具来管理系统服务。
如果没有softadm账户可以先创建该账户。
[root@svr5 ~]# vim /etc/sudoers            //修改文件后，需要使用wq强制保存
.. ..
softadm    ALL=(ALL)   /usr/bin/systemctl         
//授权softadm以root身份执行systemctl命令

2）切换为softadm用户，并验证sudo执行权限
[root@svr5 ~]# su – softadm
[softadm@svr5 ~]$ sudo -l


步骤三：允许用户useradm通过sudo方式添加/删除/修改除root以外的用户账号
1）修改/etc/sudoers配置
为useradm授予用户管理相关命令的执行权限，例外程序以!符号取反，放在后面。在执行相关程序时，可以利用通配符*。
[root@svr5 ~]# vim /etc/sudoers
.. ..
useradm ALL=(ALL)  /usr/bin/passwd,!/usr/bin/passwd root,/usr/sbin/user*,
 !/usr/sbin/user* * root

2）切换为useradm用户，验证sudo权限
可以通过sudo方式来添加/删除/修改普通用户：
[root@svr5 ~]# su – useradm
[useradm@svr5 ~]$ sudo -l
.. ..
用户useradm可以在该主机上运行以下命令：
    (root) /usr/bin/passwd, !/usr/bin/passwd root, /usr/sbin/user*,
!/usr/sbin/user* * root

步骤四：允许wheel组成员以特权执行/bin/下的所有命令
此案例用来展示sudo的便利性及设置不当带来的危险性，生产环境下慎用。
实现时参考下列操作(如果没有普通用户则先创建该账户)：
[root@svr5 ~]# vim /etc/sudoers
.. ..
%wheel ALL=(ALL)  /bin/*

步骤五：为sudo机制启用日志记录，以便跟踪sudo执行操作
1）修改/etc/sudoers配置，添加日志设置
[root@svr5 ~]# visudo
Defaults  logfile="/var/log/sudo"


3.2 步骤

实现此案例需要按照如下步骤进行。
步骤一：配置基本安全策略
1）调整sshd服务配置，并重载服务
[root@svr5 ~]# vim /etc/ssh/sshd_config
.. ..
Protocol 2                                          //去掉SSH协议V1
PermitRootLogin no                                  //禁止root用户登录
PermitEmptyPasswords no                              //禁止密码为空的用户登录
UseDNS  no                                          //不解析客户机地址
LoginGraceTime  1m                                  //登录限时
MaxAuthTries  3                                      //每连接最多认证次数
.. ..
[root@svr5 ~]# systemctl restart sshd

步骤二：针对SSH访问采用仅允许的策略，未明确列出的用户一概拒绝登录
1）调整sshd服务配置，添加AllowUsers策略，仅允许用户zengye、john、useradm，其中useradm只能从网段192.168.4.0/24登录。
[root@svr5 ~]# vim /etc/ssh/sshd_config
.. ..
AllowUsers zengye john useradm@192.168.4.0/24            //定义账户白名单
##DenyUsers  USER1  USER2                                //定义账户黑名单
##DenyGroups  GROUP1 GROUP2                            //定义组黑名单
##AllowGroups  GROUP1 GROUP2                            //定义组白名单
[root@svr5 ~]# systemctl restart sshd


步骤三：实现密钥对验证登录（私钥口令）、免密码登入
1）准备客户机测试环境
为客户机的用户root建立SSH密钥对
使用ssh-keygen创建密钥对，将私钥口令设为空（直接回车）：
[root@client ~]$ ssh-keygen -t rsa
Generating public/private rsa key pair.
Enter file in which to save the key (/root/.ssh/id_rsa):
Created directory '/root/.ssh'.
Enter passphrase (empty for no passphrase):              //直接回车将口令设为空
Enter same passphrase again:                              //再次回车确认
Your identification has been saved in /root/.ssh/id_rsa.
Your public key has been saved in /root/.ssh/id_rsa.pub.
The key fingerprint is:
63:6e:cf:45:f0:56:e2:89:6f:62:64:5a:5e:fd:68:d2
The key's randomart image is:
+--[ RSA 2048]----+
|                       |
|                       |
|          . . .        |
|           = =       |
|        S = B .  |
|       o B = . o |
|        + + = E .|
|       . + + o   |
|          o      |
+-----------------+
[root@client ~]$ ls -lh ~/.ssh/id_rsa*                  //确认密钥对文件
-rw-------. 1 root root 1.8K 8月  15 10:35 /root/.ssh/id_rsa
-rw-r--r--. 1 root root  403 8月  15 10:35 /root/.ssh/id_rsa.pub

2）将客户机上用户root的公钥部署到SSH服务器
以用户root登入客户机，使用ssh-copy-id命令将自己的公钥部署到服务器：
[root@client ~]$ ssh-copy-id root@192.168.4.5
root@192.168.4.5's password:


3）在服务器上确认客户机用户root上传的公钥信息
默认部署位置为目标用户的家目录下 ~/.ssh/authorized_keys文件：
[root@svr5 ~]# tail -2 ~/.ssh/authorized_keys
ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAzz+5AiFMGQ7LfuiV7eBnOcmRO9JRTcqRoynGO2y5
RyFL+LxR1IpEbkNrUyIZDk5uaX1Y8rwsf+pa7UZ2NyqmUEvNSUo0hQyDGsU9SPyAdzRCCvDgwpOFhaHi/OFnT+zqjAqXH2M9fFYEVUU4PIVL8HT19zCQRVZ/q3acQA34UsQUR0PpLJAobsf1BLe2EDM8BsSHckDGsNoDT9vk+u3e83RaehBMuy1cVEN5sLAaIrIeyM8Q0WxQNlqknL908HRkTlTeKrRoHbMnOBFj8StwlnscKHlkrsKkhUf8A9WWz/vL4GDwGND5jdca3I2hdITAySjMdfL1HMHnMYOgMjPM0Q== root@192.168.4.100

步骤四：确认密钥验证使用正常后，禁用口令验证
1）调整sshd服务配置，将PasswordAuthentication设为no
[root@svr5 ~]# vim /etc/ssh/sshd_config
.. ..
PasswordAuthentication no                              //将此行yes改成no
[root@svr5 ~]# systemctl restart sshd


步骤一：将Linux服务器的SELinux设为enforcing强制模式
1）固定配置：修改/etc/selinux/config文件
确认或修改SELINUX为enforcing模式：
[root@svr5 ~]# vim /etc/selinux/config
SELINUX=enforcing                                //设置SELinux为强制模式
SELINUXTYPE=targeted                            //保护策略为保护主要的网络服务安全

2）临时配置：使用setenforce命令
查看当前SELinux状态，如果是disabled则需要根据第1）步的配置重启系统；如果是permissive则使用setenforce命令修改为enforcing即可：
[root@svr5 ~]# getenforce                        //查看当前状态为警告模式
Permissive
[root@svr5 ~]# setenforce 1                      //设置SELinux为强制模式
[root@svr5 ~]# getenforce                        //查看当前模式为强制模式
Enforcing
[root@svr5 ~]# setenforce 0                      //设置SELinux为强制模式
[root@svr5 ~]# getenforce                        //查看当前模式为警告模式
Permissive

//更改selinux标签
[root@svr5 ~]# chcon -t public_content_t /var/ftp/d2.tar.gz

#########################################################################

加密算法主要有以下几种分类：
1.为确保数据机密性算法：
a) 对称加密算法(AES,DES)
b) 非对称加密算法（RSA，DSA）
2.为确保数据完整性算法：
a) 信息摘要（MD5，SHA256，SHA512）


步骤二：使用GPG对称加密方式保护文件

GnuPG是非常流行的加密软件，支持所有常见加密算法，并且开源免费使用。
1）确保已经安装了相关软件（默认已经安装好了）
[root@svr5 ~]# yum -y install gnupg2            //安装软件
[root@svr5 ~]# gpg --version                    //查看版本
gpg (GnuPG) 2.0.22

根据提示输入两次口令，加密后的文件（自动添加后缀 .gpg）就生成了，传递过程中只要发送加密的文件（比如 file2.txt.gpg）就可以了。

[root@svr5 ~]# cat file2.txt.gpg                    //查看加密数据为乱码

3）使用gpg对加密文件进行解密操作
收到加密的文件后，必须进行解密才能查看其内容。
[root@client ~]# gpg -d file2.txt.gpg > file2.txt      //解密后保存
gpg: 3DES 加密过的数据
.. ..                                              //根据提示输入正确密码
[root@client ~]# cat file2.txt                      //查看解密后的文件
abcdef
123456779

1）接收方UserA创建自己的公钥、私钥对(在192.168.4.100操作)
执行gpg --gen-key操作，根据提示选择并创建密钥：
[root@client ~]# gpg --gen-key
… …
请选择您要使用的密钥种类：
   (1) RSA and RSA (default)                            //默认算法为RSA
   (2) DSA and Elgamal
   (3) DSA (仅用于签名)
   (4) RSA (仅用于签名)
您的选择？                                              //直接回车默认(1)
RSA 密钥长度应在 1024 位与 4096 位之间。
您想要用多大的密钥尺寸？(2048)                              //接受默认2048位
您所要求的密钥尺寸是 2048 位
请设定这把密钥的有效期限。
         0 = 密钥永不过期
      <n>  = 密钥在 n 天后过期
      <n>w = 密钥在 n 周后过期
      <n>m = 密钥在 n 月后过期
      <n>y = 密钥在 n 年后过期
密钥的有效期限是？(0)                                          //接受默认永不过期
密钥永远不会过期
以上正确吗？(y/n)y                                          //输入y确认
You need a user ID to identify your key; the software constructs the user ID
from the Real Name, Comment and Email Address in this form:
    "Heinrich Heine (Der Dichter) <heinrichh@duesseldorf.de>"
真实姓名：UserA
电子邮件地址：UserA@tarena.com
注释：UserA
您选定了这个用户标识：
    “UserA (UserA) <UserA@tarena.com>”
更改姓名(N)、注释(C)、电子邮件地址(E)或确定(O)/退出(Q)？O          //输入大写O确认
您需要一个密码来保护您的私钥。
我们需要生成大量的随机字节。这个时候您可以多做些琐事(像是敲打键盘、移动
鼠标、读写硬盘之类的)，这会让随机数字发生器有更好的机会获得足够的熵数。
gpg: 正在检查信任度数据库
gpg: 需要 3 份勉强信任和 1 份完全信任，PGP 信任模型
gpg: 深度：0 有效性：  1 已签名：  0 信任度：0-，0q，0n，0m，0f，1u
pub   2048R/421C9354 2017-08-16
密钥指纹 = 8A27 6FB5 1315 CEF8 D8A0  A65B F0C9 7DA6 421C 9354
uid                  UserA (UserA) <UserA@tarena.com>
sub   2048R/9FA3AD25 2017-08-16

2）UserA导出自己的公钥文件(在192.168.4.100操作)
用户的公钥、私钥信息分别保存在pubring.gpg和secring.gpg文件内：
[root@client ~]# gpg --list-keys                          //查看公钥环
/root/.gnupg/pubring.gpg
------------------------------
pub   2048R/421C9354 2017-08-16
uid                  UserB (User B) <UserB@tarena.com>
sub   2048R/9FA3AD25 2017-08-16


使用gpg命令结合--export选项将其中的公钥文本导出，传给发送方UserA：
[root@client ~]# gpg -a --export UserB > /tmp/UserA.pub
//--export的作用是导出密钥，-a的作用是导出的密钥存储为ASCII格式
[root@client ~]# scp /tmp/UserA.pub 192.168.4.5:/tmp/    //将密钥传给UserB

3）UserB导入接收的公钥信息
使用gpg命令结合--import选项导入发送方的公钥信息，以便在加密文件时指定对应的公钥。
[root@svr5 ~]# gpg --import /tmp/UserA.pub
gpg: 密钥 421C9354：公钥“UserA (UserA) <UserA@tarena.com>”已导入
gpg: 合计被处理的数量：1
gpg:           已导入：1  (RSA: 1) 


4) UserB使用导入的公钥加密数据，并把加密后的数据传给UserA
[root@svr5 ~]# echo "I love you ." > love.txt
[root@svr5 ~]# gpg -e -r UserA love.txt
无论如何还是使用这把密钥吗？(y/N)y                          //确认使用此密钥加密文件
[root@svr5 ~]# scp love.txt.gpg  192.168.4.100:/root    //加密的数据传给UserA

4）UserA以自己的私钥解密文件
[root@client ~]# gpg -d love.txt.gpg > love.txt
您需要输入密码，才能解开这个用户的私钥：“UserA (UserA) <UserA@tarena.com>”
2048 位的 RSA 密钥，钥匙号 9FA3AD25，建立于 2017-08-16 (主钥匙号 421C9354)
                                                  //验证私钥口令
gpg: 由 2048 位的 RSA 密钥加密，钥匙号为 9FA3AD25、生成于 2017-08-16
      “UserA (UserA) <UserA@tarena.com>”
[root@client ~]# cat love.txt                      //获得解密后的文件内容
I love you.

步骤四：使用GPG的签名机制，检查数据来源的正确性

使用私钥签名的文件，是可以使用对应的公钥验证签名的，只要验证成功，则说明这个文件一定是出自对应的私钥签名，除非私钥被盗，否则一定能证明这个文件来自于某个人！
1）在client(192.168.4.100)上，UserA为软件包创建分离式签名
将软件包、签名文件、公钥文件一起发布给其他用户下载。
[root@client ~]# tar zcf log.tar /var/log              //建立测试软件包
[root@client ~]# gpg -b log.tar                      //创建分离式数字签名
[root@client ~]# ls -lh log.tar* UserA.pub
-rw-rw-r--. 1 root root 170 8月  17 21:18 log.tar
-rw-rw-r--. 1 root root 287 8月  17 21:22 log.tar.sig
[root@client ~]# scp log.tar* 192.168.4.5:/root        //将签名文件与签名传给UserB

2）在192.168.4.5上验证签名
[root@svr5 ~]# gpg --verify log.tar.sig log.tar
gpg:于2028年06月07日 星期六 23时23分23秒 CST 创建的签名，使用 RSA，钥匙号 421C9354
gpg: 完好的签名，来自于“UserA (UserA) <UserA@tarena.com>”
.. ..

2.2 方案

Aide通过检查数据文件的权限、时间、大小、哈希值等，校验数据的完整性。
使用Aide需要在数据没有被破坏前，对数据完成初始化校验，生成校验数据库文件，在被攻击后，可以使用数据库文件，快速定位被人篡改的文件。

步骤一：部署AIDE入侵检测系统

1）安装软件包
[root@svr5 ~]# yum -y install aide
2) 修改配置文件
确定对哪些数据进行校验，如何校验数据
[root@svr5 ~]# vim /etc/aide.conf
@@define DBDIR /var/lib/aide                            //数据库目录
@@define LOGDIR /var/log/aide                            //日志目录
database_out=file:@@{DBDIR}/aide.db.new.gz                //数据库文件名
//一下内容为可以检查的项目（权限，用户，组，大小，哈希值等）
#p:      permissions
#i:       inode:
#n:      number of links
#u:      user
#g:      group
#s:       size
#md5:    md5 checksum
#sha1:    sha1 checksum
#sha256:        sha256 checksum
FIPSR = p+i+n+u+g+s+m+c+acl+selinux+xattrs+sha256
//一下内容设置需要对哪些数据进行入侵校验检查
//注意：为了校验的效率，这里将所有默认的校验目录与文件都注释
//仅保留/root目录
#/boot   NORMAL                                    //对哪些目录进行什么校验
#/bin    NORMAL
#/sbin   NORMAL
#/lib    NORMAL
#/lib64  NORMAL
#/opt    NORMAL
#/usr    NORMAL
/root   NORMAL
#!/usr/src                                        //使用[!]，设置不校验的目录
#!/usr/tmp
步骤二：初始化数据库，入侵后检测

1）入侵前对数据进行校验，生成初始化数据库
[root@svr5 ~]# aide --init
AIDE, version 0.15.1
AIDE database at /var/lib/aide/aide.db.new.gz initialized.
//生成校验数据库，数据保存在/var/lib/aide/aide.db.new.gz

2）备份数据库，将数据库文件拷贝到U盘（非必须的操作）
[root@svr5 ~]# cp /var/lib/aide/aide.db.new.gz   /media/
3）入侵后检测
[root@svr5 ~]# cd /var/lib/aide/
[root@svr5 ~]# mv aide.db.new.gz aide.db.gz
[root@svr5 ~]# aide --check                            //检查哪些数据发生了变化

扫描与抓包分析
3.1 问题

本案例要求熟悉Linux主机环境下的常用安全工具，完成以下任务操作：
使用NMAP扫描来获取指定主机/网段的相关信息
使用tcpdump分析FTP访问中的明文交换信息
3.2 步骤

实现此案例需要按照如下步骤进行。
步骤一：使用NMAP扫描来获取指定主机/网段的相关信息

1）安装软件
[root@svr5 ~]# yum -y install nmap
//基本用法：
# nmap  [扫描类型]  [选项]  <扫描目标 ...>
//常用的扫描类型
// -sS，TCP SYN扫描（半开）
// -sT，TCP 连接扫描（全开）
// -sU，UDP扫描
// -sP，ICMP扫描
// -A，目标系统全面分析

2）检查目标主机所开启的TCP服务
[root@svr5 ~]# nmap 192.168.4.100

3）检查192.168.4.0/24网段内哪些主机开启了FTP、SSH、HTTP服务
[root@svr5 ~]# nmap -p 21-22,80 192.168.4.0/24 (-p加端口)

3）检查目标主机所开启的UDP服务
[root@svr5 ~]# nmap   -sU  svr7.tedu.cn                //指定-sU扫描UDP
53/udp   open          domain
111/udp  open          rpcbind

3）检查192.168.4.0/24网段内哪些主机可以ping通
[root@svr5 ~]# nmap  -n  -sP  192.168.4.0/24

4）全面分析目标主机192.168.4.100和192.168.4.5的操作系统信息
[root@svr5 ~]# nmap -A 192.168.4.100,5

步骤二：使用tcpdump分析FTP访问中的明文交换信息

1）启用tcpdump命令行抓包
执行tcpdump命令行，添加适当的过滤条件，只抓取访问主机192.168.4.100的21端口的数据通信 ，并转换为ASCII码格式的易读文本。
[root@svr5 ~]# tcpdump -A host 192.168.4.5 and tcp port 21
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth0, link-type EN10MB (Ethernet), capture size 65535 bytes
.. ..                                            //进入等待捕获数据包的状态
//监控选项如下：
// -i，指定监控的网络接口
// -A，转换为 ACSII 码，以方便阅读
// -w，将数据包信息保存到指定文件
// -r，从指定文件读取数据包信息

//tcpdump的过滤条件：
// 类型：host、net、port、portrange
// 方向：src、dst
// 协议：tcp、udp、ip、wlan、arp、……
// 多个条件组合：and、or、not

2）执行FTP访问，并观察tcpdump抓包结果
参考前面的测试操作，再次从客户机192.168.4.100访问主机192.168.4.5的vsftpd服务。然后使用tcpdump抓包，仔细分析FTP连接的建立过程、确认收集到的用户名和口令信息。
[root@svr5 ~]# tcpdump  -A  -w  ftp.cap  \
> host 192.168.4.5  and  tcp  port  21                            //抓包并保存
[root@svr5 ~]# tcpdump  -A  -r  ftp.cap | egrep  '(USER|PASS)'    //分析数据包
.. ..

##############################################################


审计能够记录的日志内容：
a) 日期与事件以及事件的结果
b) 触发事件的用户
c) 所有认证机制的使用都可以被记录，如ssh等
d) 对关键数据文件的修改行为等都可以被记录

1）安装软件包，查看配置文件（确定审计日志的位置）
[root@svr5 ~]# yum -y  install  audit                //安装软件包
[root@svr5 ~]# cat /etc/audit/auditd.conf            //查看配置文件，确定日志位置
log_file = /var/log/audit/audit.log                //日志文件路径
[root@svr5 ~]# systemctl start auditd                //启动服务
[root@svr5 ~]# systemctl enable auditd                //设置开机自启

2）配置审计规则
可以使用auditctl命令控制审计系统并设置规则决定哪些行为会被记录日志。
语法格式如下：
[root@svr5 ~]# auditctl  -s                        //查询状态
[root@svr5 ~]# auditctl  -l                        //查看规则
[root@svr5 ~]# auditctl  -D                        //删除所有规则

定义临时文件系统规则：
#语法格式：auditctl  -w  path  -p  permission  -k  key_name
# path为需要审计的文件或目录
# 权限可以是r,w,x,a(文件或目录的属性发生变化)
# Key_name为可选项，方便识别哪些规则生成特定的日志项
[root@svr5 ~]# auditctl  -w  /etc/passwd  -p wa  -k  passwd_change
//设置规则所有对passwd文件的写、属性修改操作都会被记录审计日志
 [root@svr5 ~]# auditctl  -w  /etc/selinux/  -p wa  -k  selinux_change
//设置规则，监控/etc/selinux目录
 [root@svr5 ~]# auditctl  -w  /usr/sbin/fdisk  -p x  -k  disk_partition
//设置规则，监控fdisk程序
[root@svr5 ~]# auditclt  -w  /etc/ssh/sshd_conf  -p warx  -k  sshd_config
//设置规则，监控sshd_conf文件

如果需要创建永久审计规则，则需要修改规则配置文件：
[root@svr5 ~]# vim  /etc/audit/rules.d/audit.rules
-w /etc/passwd -p wa -k passwd_changes
-w /usr/sbin/fdisk -p x -k partition_disks

步骤二：查看并分析日志

1）手动查看日志
查看SSH的主配置文件/etc/ssh/sshd_conf，查看audit日志信息：
[root@svr5 ~]# tailf  /var/log/audit/audit.log

2）通过工具搜索日志
系统提供的ausearch命令可以方便的搜索特定日志，默认该程序会搜索/var/log/audit/audit.log，ausearch options -if file_name可以指定文件名。
[root@svr5 ~]# ausearch -k sshd_config -i    
//根据key搜索日志，-i选项表示以交互式方式操作

案例2：加固常见服务的安全
2.1 问题

本案例要求优化提升常见网络服务的安全性，主要完成以下任务操作：
优化Nginx服务的安全配置
优化MySQL数据库的安全配置
优化Tomcat的安全配置
2.2 方案

Nginx安全优化包括：删除不要的模块、修改版本信息、限制并发、拒绝非法请求、防止buffer溢出。
MySQL安全优化包括：初始化安全脚本、密码安全、备份与还原、数据安全。
Tomcat安全优化包括：隐藏版本信息、降权启动、删除默认测试页面.

步骤一：优化Nginx服务的安全配置

1） 删除不需要的模块
Nignx是模块化设计的软件，需要什么功能与模块以及不需要哪些模块，都可以在编译安装软件时自定义，使用--with参数可以开启某些模块，使用--without可以禁用某些模块。最小化安装永远都是对的方案！
下面是禁用某些模块的案例：
[root@svr5 ~]# tar -xf nginx-1.12.tar.gz
[root@svr5 ~]# cd nginx-1.12
[root@svr5 nginx-1.12]# ./configure \
>--without-http_autoindex_module \            //禁用自动索引文件目录模块
>--without-http_ssi_module
[root@svr5 nginx-1.12]# make
[root@svr5 nginx-1.12]# make install

2） 修改版本信息，并隐藏具体的版本号
默认Nginx会显示版本信息以及具体的版本号，这些信息给攻击者带来了便利性，便于他们找到具体版本的漏洞。
如果需要屏蔽版本号信息，执行如下操作，可以隐藏版本号。
[root@svr5 ~]# vim /usr/local/nginx/conf/nginx.conf
… …
http{
     server_tokens off;                            //在http下面手动添加这么一行
     … …
}
[root@svr5 ~]# nginx -s reload
[root@svr5 ~]# curl -I http://192.168.4.5          //查看服务器响应的头部信息

但服务器还是显示了使用的软件为nginx，通过如下方法可以修改该信息。
[root@svr5 nginx-1.12]# vim +48 src/http/ngx_http_header_filter_module.c
//注意：vim这条命令必须在nginx-1.12源码包目录下执行！！！！！！
//该文件修改前效果如下：
static u_char ngx_http_server_string[] = "Server: nginx" CRLF;
static u_char ngx_http_server_full_string[] = "Server: " NGINX_VER CRLF;
static u_char ngx_http_server_build_string[] = "Server: " NGINX_VER_BUILD CRLF;
//下面是我们修改后的效果：
static u_char ngx_http_server_string[] = "Server: Jacob" CRLF;
static u_char ngx_http_server_full_string[] = "Server: Jacob" CRLF;
static u_char ngx_http_server_build_string[] = "Server: Jacob" CRLF;
//修改完成后，再去编译安装Nignx，版本信息将不再显示为Nginx，而是Jacob
[root@svr5 nginx-1.12]# ./configure
[root@svr5 nginx-1.12]# make && make install
[root@svr5 nginx-1.12]# killall nginx
[root@svr5 nginx-1.12]# /usr/local/nginx/sbin/nginx            //启动服务
[root@svr5 nginx-1.12]# curl -I http://192.168.4.5            //查看版本信息验证

3） 限制并发量
DDOS攻击者会发送大量的并发连接，占用服务器资源（包括连接数、带宽等），这样会导致正常用户处于等待或无法访问服务器的状态。
Nginx提供了一个ngx_http_limit_req_module模块，可以有效降低DDOS攻击的风险，操作方法如下：
[root@svr5 ~]# vim /usr/local/nginx/conf/nginx.conf
… …
http{
… …
limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;
    server {
        listen 80;
        server_name localhost;
        limit_req zone=one burst=5;
            }
}
//备注说明：
//limit_req_zone语法格式如下：
//limit_req_zone key zone=name:size rate=rate;
//上面案例中是将客户端IP信息存储名称为one的共享内存，内存空间为10M
//1M可以存储8千个IP信息，10M可以存储8万个主机连接的状态，容量可以根据需要任意调整
//每秒中仅接受1个请求，多余的放入漏斗
//漏斗超过5个则报错
[root@svr5 ~]# /usr/local/nginx/sbin/nginx -s reload

客户端使用ab测试软件测试效果：
[root@client ~]# ab -c 100 -n 100  http://192.168.4.5/

4） 拒绝非法的请求
网站使用的是HTTP协议，该协议中定义了很多方法，可以让用户连接服务器，获得需要的资源。但实际应用中一般仅需要get和post。

请求方法		功能描述
GET		请求指定的页面信息，并返回实体主体
HEAD		类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头
POST		向指定资源提交数据进行处理请求
DELETE	请求服务器删除指定的页面
PUT		向服务器特定位置上传资料

未修改服务器配置前，客户端使用不同请求方法测试：
[root@client ~]# curl -i -X GET  http://192.168.4.5          //正常
[root@client ~]# curl -i -X HEAD http://192.168.4.5          //正常
//curl命令选项说明：
//-i选项：访问服务器页面时，显示HTTP的头部信息
//-X选项：指定请求服务器的方法

通过如下设置可以让Nginx拒绝非法的请求方法：
[root@svr5 ~]# vim /usr/local/nginx/conf/nginx.conf
http{
       server {
     listen 80;
              if ($request_method !~ ^(GET|POST)$ ) {
                     return 444;
               }    
        }
}

修改服务器配置后，客户端使用不同请求方法测试：
[root@client ~]# curl -i -X GET  http://192.168.4.5            //正常
[root@client ~]# curl -i -X HEAD http://192.168.4.5            //报错

4） 防止buffer溢出
当客户端连接服务器时，服务器会启用各种缓存，用来存放连接的状态信息。
如果攻击者发送大量的连接请求，而服务器不对缓存做限制的话，内存数据就有可能溢出（空间不足）。
修改Nginx配置文件，调整各种buffer参数，可以有效降低溢出风险。
[root@svr7 ~]# vim /usr/local/nginx/conf/nginx.conf
http{
client_body_buffer_size  1K;
client_header_buffer_size 1k;
client_max_body_size 1k;
large_client_header_buffers 2 1k;
 … …
}

步骤二：数据库安全

1） 初始化安全脚本
安装完MariaDB或MySQL后，默认root没有密码，并且提供了一个任何人都可以操作的test测试数据库。有一个名称为mysql_secure_installation的脚本，该脚本可以帮助我们为root设置密码，并禁止root从远程其他主机登陆数据库，并删除测试性数据库test。
[root@svr5 ~]# systemctl status mariadb
//确保服务已启动 
[root@svr5 ~]# mysql_secure_installation
//执行初始化安全脚本

2）密码安全
手动修改MariaDB或MySQL数据库密码的方法：
[root@svr5 ~]# mysqladmin -uroot -predhat password 'mysql'
//修改密码，旧密码为redhat，新密码为mysql
[root@svr5 ~]# mysql -uroot -pmysql
MariaDB [(none)]>set password for root@'localhost'=password('redhat')
//使用账户登录数据库，修改密码

修改密码成功，而且密码在数据库中是加密的，有什么问题吗？问题是你的密码被明文记录了，下面来看看名为密码：
[root@svr5 ~]# cat .bash_history
mysqladmin -uroot -pxxx password 'redhat'
//通过命令行修改的密码，bash会自动记录历史，历史记录中记录了明文密码
[root@svr5 ~]# cat .mysql_history 

3）数据备份与还原
首先，备份数据库（注意用户名为root，密码为redhat）：
[root@svr5 ~]# mysqldump -uroot -predhat mydb table > table.sql
//备份数据库中的某个数据表
[root@svr5 ~]# mysqldump -uroot -predhat mydb > mydb.sql
//备份某个数据库
[root@svr5 ~]# mysqldump -uroot -predhat --all-databases > all.sql
//备份所有数据库

接下来，还原数据库（注意用户名为root，密码为redhat）：
[root@svr5 ~]# mysql -uroot -predhat mydb  < table.sql  //还原数据表
[root@svr5 ~]# mysql -uroot -predhat mydb <mydb.sql     //还原数据库
[root@svr5 ~]# mysql -uroot -predhat <all.sql      //还原所有数据库

4）数据安全
在服务器上（192.168.4.5），创建一个数据库账户：
[root@svr5 ~]# mysql -uroot -predhat
//使用管理员，登陆数据库
MariaDB [(none)]> grant all on *.* to tom@'%' identified by '123';
//创建一个新账户tom

使用tcpdump抓包（192.168.4.5）
[root@svr5 ~]# tcpdump -w log -i any src or dst port 3306
//抓取源或目标端口是3306的数据包，保存到log文件中


客户端（192.168.4.100）从远程登陆数据库服务器（192.168.4.5）
[root@client ~]# mysql -utom -p123 -h 192.168.4.5
//在192.168.4.100这台主机使用mysql命令登陆远程数据库服务器（192.168.4.5）
//用户名为tom，密码为123
MariaDB [(none)]> select * from mysql.user;
//登陆数据库后，任意执行一条查询语句

回到服务器查看抓取的数据包
[root@svr7 ~]# tcpdump -A -r log
//使用tcpdump查看之前抓取的数据包，很多数据库的数据都明文显示出来

如何解决？
可以使用SSH远程连接服务器后，再从本地登陆数据库（避免在网络中传输数据，因为网络环境中不知道有没有抓包者）。

步骤三：Tomcat安全性

1） 隐藏版本信息、修改tomcat主配置文件（隐藏版本信息）
未修改版本信息前，使用命令查看服务器的版本信息
[root@web1 ~]# curl -I http://192.168.2.100:8080/xx        
//访问不存在的页面文件，查看头部信息
[root@web1 ~]# curl -I http://192.168.2.100:8080    
//访问存在的页面文件，查看头部信息
[root@web1 ~]# curl http://192.168.2.100:8080/xx
//访问不存在的页面文件，查看错误信息

修改tomcat配置文件，修改版本信息：
[root@web1 tomcat]# yum -y install java-1.8.0-openjdk-devel
[root@web1 tomcat]# cd /usr/local/tomcat/lib/
[root@web1 lib]# jar -xf catalina.jar
[root@web1 lib]# vim org/apache/catalina/util/ServerInfo.properties 
//根据自己的需要，修改版本信息的内容
[root@web1 lib]# /usr/local/tomcat/bin/shutdown.sh        //关闭服务
[root@web1 lib]# /usr/local/tomcat/bin/startup.sh        //启动服务

修改后再次查看版本信息：
[root@web1 ~]# curl -I http://192.168.2.100:8080/xx        
//访问不存在的页面文件，查看头部信息
[root@web1 ~]# curl -I http://192.168.2.100:8080    
//访问存在的页面文件，查看头部信息
[root@web1 ~]# curl http://192.168.2.100:8080/xx
//访问不存在的页面文件，查看错误信息

再次修改tomcat服务器配置文件，修改版本信息，手动添加server参数：
[root@web1 lib]# vim /usr/local/tomcat/conf/server.xml
<Connector port="8080" protocol="HTTP/1.1"
connectionTimeout="20000"  redirectPort="8443" server="jacob" />
[root@web1 lib]# /usr/local/tomcat/bin/shutdown.sh        //关闭服务
[root@web1 lib]# /usr/local/tomcat/bin/startup.sh        //启动服务

修改后再次查看版本信息：
[root@web1 ~]# curl -I http://192.168.2.100:8080/xx        
//访问不存在的页面文件，查看头部信息
[root@web1 ~]# curl -I http://192.168.2.100:8080    
//访问存在的页面文件，查看头部信息
[root@web1 ~]# curl http://192.168.2.100:8080/xx
//访问不存在的页面文件，查看错误信息

2）降级启动
默认tomcat使用系统高级管理员账户root启动服务，启动服务尽量使用普通用户。
[root@web1 ~]# useradd tomcat
[root@web1 ~]# chown -R tomcat:tomcat /usr/local/tomcat/
//修改tomcat目录的权限，让tomcat账户对该目录有操作权限
[root@web1 ~]# su -c /usr/local/tomcat/bin/startup.sh tomcat
//使用su命令切换为tomcat账户，以tomcat账户的身份启动tomcat服务
[root@svr7 ~]# chmod +x /etc/rc.local                //该文件为开机启动文件
[root@svr7 ~]# vim /etc/rc.local                     //修改文件，添加如下内容
su -c /usr/local/tomcat/bin/startup.sh tomcat


3 案例3：使用diff和patch工具打补丁
3.1 问题

本案例要求优化提升常见网络服务的安全性，主要完成以下任务操作：
使用diff对比文件差异
使用diff生成补丁文件
使用patch命令为旧版本打补丁

步骤一：对比单个文件差异

1） 编写两个版本的脚本，一个为v1版本，一个为v2版本。
[root@svr5 ~]# cat test1.sh                       //v1版本脚本
#!/bin/bash
echo "hello wrld"
[root@svr5 ~]# cat test2.sh                      //v2版本脚本
#!/bin/bash
echo "hello world"
echo "test file"

2） 使用diff命令语法
使用diff命令查看不同版本文件的差异。
[root@svr5 ~]# diff  test1.sh test2.sh                     //查看文件差异
@@ -1,3 +1,3 @@
 #!/bin/bash
-echo "hello world"
-echo "test"
+echo "hello the world"
+echo "test file"


[root@svr5 ~]# diff -u test1.sh test2.sh                 //查看差异，包含头部信息
--- test1.sh    2018-02-07 22:20:02.723971251 +0800
+++ test2.sh    2018-02-07 22:20:13.358760687 +0800
@@ -1,3 +1,3 @@
 #!/bin/bash
-echo "hello world"
-echo "test"
+echo "hello the world"
+echo "test file"

diff制作补丁文件的原理：告诉我们怎么修改第一个文件后能得到第二个文件。
这样如果第一个版本的脚本有漏洞，我们不需要将整个脚本都替换，仅需要修改有问题的一小部分代码即可，diff刚好可以满足这个需求！
像Linux内核这样的大块头，一旦发现有一个小漏洞，我们不可能把整个内核都重新下载，全部替换一遍，而仅需要更新有问题的那一小部分代码即可！
diff命令常用选项：
-u	输出统一内容的头部信息（打补丁使用），计算机知道是哪个文件需要修改
-r	递归对比目录中的所有资源（可以对比目录）
-a	所有文件视为文本（包括二进制程序）
-N	无文件视为空文件（空文件怎么变成第二个文件）
-N选项备注说明：
A目录下没有txt文件，B目录下有txt文件
diff比较两个目录时，默认会提示txt仅在B目录有（无法对比差异，修复文件）
diff比较时使用N选项，则diff会拿B下的txt与A下的空文件对比，补丁信息会明确说明如何从空文件修改后变成txt文件，打补丁即可成功！

步骤二：使用patch命令对单文件代码打补丁

1）准备实验环境
[root@svr5 ~]# cd demo
[root@svr5 demo]# vim test1.sh
#!/bin/bash
echo "hello world"
echo "test"
[root@svr5 demo]# vim test2.sh 
#!/bin/bash
echo "hello the world"
echo "test file"

2) 生成补丁文件
[root@svr5 demo]# diff -u test1.sh test2.sh > test.patch

3）使用patch命令打补丁
在代码相同目录下为代码打补丁
[root@svr5 demo]# yum -y install patch
[root@svr5 demo]# patch -p0 < test.patch                    //打补丁
patching file test1.sh
//patch -pnum（其中num为数字，指定删除补丁文件中多少层路径前缀）
//如原始路径为/u/howard/src/blurfl/blurfl.c
//-p0则整个路径不变
//-p1则修改路径为u/howard/src/blurfl/blurfl.c
//-p4则修改路径为blurfl/blurfl.c
//-R(reverse)反向修复，-E修复后如果文件为空，则删除该文件
[root@svr5 demo]# patch -RE < test.patch                     //还原旧版本，反向修复

步骤三：对比目录中所有文件的差异

1） 准备实验环境
[root@svr5 ~]# mkdir demo
[root@svr5 ~]# cd demo
[root@svr5 demo]# mkdir {source1,source2}
[root@svr5 demo]# echo "hello world"       > source1/test.sh
[root@svr5 demo]# cp /bin/find source1/
[root@svr5 demo]#  tree source1/                        //source1目录下2个文件
|-- find
`-- test.sh
[root@svr5 demo]# echo "hello the world"  > source2/test.sh
[root@svr5 demo]# echo "test" > source2/tmp.txt
[root@svr5 demo]# cp /bin/find source2/
[root@svr5 demo]# echo "1" >> source2/find 
[root@svr5 demo]#  tree source2/                        //source1目录下3个文件
|-- find
|-- test.sh
`-- tmp.txt
//注意：两个目录下find和test.sh文件内容不同，source2有tmp.txt而source1没有该文件

2）制作补丁文件
[root@svr5 demo]# diff -u source1/ source2/
//仅对比了文本文件test.sh；二进制文件、tmp都没有对比差异，仅提示，因为没有-a和-N选项
[root@svr5 demo]# diff -Nu source1/ source2/
//对比了test.sh，并且使用source2目录的tmp.txt与source1的空文件对比差异。
[root@svr5 demo]# diff -Nua source1/ source2/
//对比了test.sh、tmp.txt、find(程序)。

步骤四：使用patch命令对目录下的所有代码打补丁

1）使用前面创建的source1和source2目录下的代码为素材，生成补丁文件
[root@svr5 ~]# cd demo
[root@svr5 demo]# diff -Nuar source1/ source2/ > source.patch
2）使用patch命令为代码打补丁
[root@svr7 demo]# ls
source1  source2  source.patch
[root@svr7 demo]# cat source.patch                //对比的文件有路径信息
--- source1/test.sh 2018-02-07 22:51:33.034879417 +0800
+++ source2/test.sh 2018-02-07 22:47:32.531754268 +0800
@@ -1 +1 @@
-hello world
+hello the world
[root@svr7 demo]# cd source1
[root@svr7 source1]# patch  -p1 < ../source.patch

#######################################################

本案例要求练习iptables命令的使用，按照要求完成以下任务：
关闭firewalld，开启iptables服务
查看防火墙规则
追加、插入防火墙规则
删除、清空防火墙规则
1.2 步骤

实现此案例需要按照如下步骤进行。
步骤一：关闭firewalld，启动iptables服务

1）关闭firewalld服务器
[root@svr5 ~]# systemctl stop firewalld.service 
[root@svr5 ~]# systemctl disable firewalld.service

2）安装iptables-services并启动服务
[root@svr5 ~]# yum -y install iptables-services
[root@svr5 ~]# systemctl start iptables.service

步骤二：熟悉iptables框架

1）iptables的4个表（区分大小写）：
iptables默认有4个表，nat表（地址转换表）、filter表（数据过滤表）、raw表（状态跟踪表）、mangle表（包标记表）。
2）iptables的5个链（区分大小写）：
INPUT链（入站规则）
OUTPUT链（出站规则）
FORWARD链（转发规则）
PREROUTING链（路有前规则）
POSTROUTING链（路由后规则）

步骤三：iptables命令的基本使用方法

1）iptabels语法格式
[root@svr5 ~]# iptables  [-t 表名]  选项  [链名]  [条件]  [-j 目标操作]
[root@svr5 ~]# iptables  -t  filter  -I  INPUT -p  icmp  -j  REJECT
[root@svr5 ~]# iptables -t filter -I  INPUT   -p  icmp  -j  ACCEPT
[root@svr5 ~]# iptables  -I  INPUT  -p  icmp  -j  REJECT
//注意事项与规律：
//可以不指定表，默认为filter表
//可以不指定链，默认为对应表的所有链
//除非设置默认策略，否则必须指定匹配条件
//选项/链名/目标操作用大写字母，其余都小写
########################################################################
//目标操作：
// ACCEPT：允许通过/放行
// DROP：直接丢弃，不给出任何回应
// REJECT：拒绝通过，必要时会给出提示
// LOG：记录日志，然后传给下一条规则

类别		选项			描述
添加规则	-A			追加一条防火墙规则至链的末尾位置
		-I			插入一条防火墙规则至链的开头

查看规则	-L			查看iptable所有规则
		-n			以数字形式显示地址、端口等信息
		--line-numbers	查看规则时，显示规则的行号

删除规则	-D			删除链内指定序号（或内容）的一条规则
		-F			清空所有的规则
默认规则	-P			为指定的链设置默认规则


2）iptables命令的使用案例
创建规则的案例：
[root@svr5 ~]# iptables  -t  filter  -A  INPUT  -p tcp  -j  ACCEPT
//追加规则至filter表中的INPUT链的末尾，允许任何人使用TCP协议访问本机
[root@svr5 ~]# iptables  -I  INPUT  -p  udp  -j  ACCEPT
//插入规则至filter表中的INPUT链的开头，允许任何人使用UDP协议访问本机
[root@svr5 ~]# iptables  -I  INPUT 2  -p  icmp  -j  ACCEPT
//插入规则至filter表中的INPUT链的第2行，允许任何人使用ICMP协议访问本机

查看iptables防火墙规则
[root@svr5 ~]# iptables  -nL  INPUT                    //仅查看INPUT链的规则
[root@svr5 ~]# iptables  -L  INPUT  --line-numbers        //查看规则，显示行号

删除规则，清空所有规则
[root@svr5 ~]# iptables  -D  INPUT  3
//删除filter表中INPUT链的第3条规则

[root@svr5 ~]# iptables  -F
//清空filter表中所有链的防火墙规则
[root@svr5 ~]# iptables  -t  nat  -F

设置防火墙默认规则
[root@svr5 ~]# iptables  -t  filter  -P  INPUT  DROP

步骤一：iptables防火墙规则的条件

iptables防火墙可以根据很多很灵活的规则进行过滤行为，具体常用的过滤条件如表-2所示。

类别		选项		用法
通用匹配	协议匹配	-p 协议名称
		地址匹配	-s 源地址、-d目标地址
		接口匹配	-i 接受数据的网卡、-o发送数据的网卡
隐含		端口匹配	--sport 源端口号、--dport 目标端口号
		ICMP类型匹配	--icmp-type ICMP 类型

1）主机型防火墙案例
[root@svr5 ~]# iptables -I INPUT -p tcp --dport 80 -j REJECT
[root@svr5 ~]# iptables -I INPUT -s 192.168.2.100 -j REJECT
[root@svr5 ~]# iptables -I INPUT -d 192.168.2.5 -p tcp --dport 80 -j REJECT
[root@svr5 ~]# iptables -I INPUT -i eth0 -p tcp --dport 80 -j REJECT
[root@svr5 ~]# iptables  -A  INPUT  -s 192.168.4.120  -j  DROP
//丢弃192.168.4.120发给本机的所有数据包
[root@svr5 ~]# iptables  -A  INPUT -s  10.0.10.0/24  -j  DROP
//丢弃10.0.10.0/24网络中所有主机发送给本机的所有数据包
[root@svr5 ~]# iptables -A  INPUT -s  114.212.33.12  -p tcp --dport 22-j  REJECT
//拒绝114.212.33.12使用tcp协议远程连接本机ssh（22端口）

步骤二：开启Linux的路由转发功能

1）Linux内核默认支持软路由功能，通过修改内核参数即可开启或关闭路由转发功能。
[root@svr5 ~]# echo 0 > /proc/sys/net/ipv4/ip_forward            //关闭路由转发
[root@svr5 ~]# echo 1 > /proc/sys/net/ipv4/ip_forward            //开启路由转发
//注意以上操作仅当前有效，计算机重启后无效
[root@svr5 ~]# echo 'net.ipv4.ip_forward=1' >> /etc/sysctl.conf
//修改/etc/sysctl.conf配置文件，可以实现永久有效规则


步骤三：禁ping的相关策略

1）默认直接禁ping的问题？
[root@router ~]# iptables -I INPUT -p icmp -j DROP
//设置完上面的规则后，其他主机确实无法ping本机，但本机也无法ping其他主机
//当本机ping其他主机，其他主机回应也是使用icmp，对方的回应被丢弃
2）禁止其他主机ping本机，允许本机ping其他主机
[root@router ~]# iptables  -A  INPUT  -p icmp  \
> --icmp-type echo-request  -j  DROP

注意：关闭ICMP的类型，可以参考help帮助，参考命令如下：
[root@router ~]# iptables -p icmp --help

3 案例3：防火墙扩展规则
3.1 问题

本案例要求熟悉使用iptables的扩展规则，实现更丰富的过滤功能，完成以下任务：
根据MAC地址封锁主机
在一条规则中开放多个TCP服务
根据IP范围设置封锁规则
3.2 方案
iptables在基本过滤条件的基础上还扩展了很多其他条件，在使用时需要使用-m参数来启动这些扩展功能，语法如下：
iptables 选项 链名称 -m 扩展模块 --具体扩展条件 -j 动作

步骤一：根据MAC地址过滤

1）根据IP过滤的确定是对方修改IP后，防火墙是失效
[root@router ~]# iptables -F
[root@router ~]# iptables -I INPUT -s 192.168.4.100 -p tcp --dport 22 -j DROP
//设置规则禁止192.168.4.100使用ssh远程本机

但是，当client主机修改IP地址后，该规则就会失效，注意因为修改了IP，对client主机的远程连接会断开，需要使用virt-manager开启虚拟机操作：
[root@client ~]# ifconfig eth0  192.168.4.101
[root@client ~]# ssh 192.168.4.5                    //依然成功

根据MAC地址过滤，可以防止这种情况的发生
[root@client ~]# ip link show eth0                    //查看client的MAC地址
eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP mode DEFAULT qlen 1000
link/ether 52:54:00:00:00:0b brd ff:ff:ff:ff:ff:ff
[root@router ~]# iptables  -A  INPUT  -p tcp --dport 22\
> -m   mac --mac-source  52:54:00:00:00:0b  -j  DROP
//拒绝52:54:00:00:00:0b这台主机远程本机

步骤二：基于多端口设置过滤规则

1）一次需要过滤或放行很多端口时会比较方便
[root@router ~]# iptables  -A  INPUT  -p tcp   \
> -m  multiport --dports  20:22,25,80,110,143,16501:16800  -j  ACCEPT
//一次性开启20,21,22,25,80,110,143,16501到16800所有的端口

步骤三：根据IP地址范围设置规则

1）允许从 192.168.4.10-192.168.4.20 登录
[root@router ~]# iptables  -A  INPUT  -p tcp  --dport  22  \
> -m  iprange  --src-range  192.168.4.10-192.168.4.20   -j  ACCEPT

2）禁止从 192.168.4.0/24 网段其他的主机登录
[root@router ~]# iptables -A INPUT -p tcp --dport 22  -s 192.168.4.0/24  -j  DROP

4 案例4：配置SNAT实现共享上网
4.1 问题

本案例要求设置防火墙规则，允许位于局域网中的主机可以访问外网，主要包括下列服务：
搭建内外网案例环境
配置SNAT策略实现共享上网访问

步骤二：设置防火墙规则，实现IP地址的伪装（SNAT源地址转换）

1）确保router主机开启了路由转发功能
[root@router ~]# echo 1 > /proc/sys/net/ipv4/ip_forward            //开启路由转发
2）设置防火墙规则，实现SNAT地址转换
[root@router ~]# iptables  -t  nat  -A POSTROUTING \
> -s  192.168.4.0/24 –p tcp --dport 80  -j SNAT  --to-source 192.168.2.5


3）登陆web主机查看日志
[root@router ~]# tail  /var/log/httpd/access_log
.. ..
192.168.2.5 - - [12/Aug/2018:17:57:10 +0800] "GET / HTTP/1.1" 200 27 "-" "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)"
通过日志会发现，客户端是先伪装为了192.168.2.5之后再访问的web服务器！
################################################################
5.1 源NAT(SNAT)

比如，更改所有来自192.168.1.0/24的数据包的源ip地址为1.2.3.4：
iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -o eth0 -j SNAT --to 1.2.3.4

这里需要注意的是，系统在路由及过虑等处理直到数据包要被送出时才进行SNAT。

有一种SNAT的特殊情况是ip欺骗，也就是所谓的Masquerading，通常建议在使用拨号上网的时候使用，或者说在合法ip地址不固定的情况下使用。比如
# iptables -t nat -A POSTROUTING -o ppp0 -j MASQUERADE

可以看出，这时候我们没有必要显式的指定源ip地址等信息。

5.2 目的SNAT(DNAT)

比如，更改所有来自192.168.1.0/24的数据包的目的ip地址为1.2.3.4：
iptables -t nat -A PREROUTING -s 192.168.1.0/24 -i eth1 -j DNAT --to 1.2.3.4

这里需要注意的是，系统是先进行DNAT，然后才进行路由及过虑等操作。

有一种DNAT的特殊情况是重定向，也就是所谓的Redirection，这时候就相当于将符合条件的数据包的目的ip地址改为数据包进入系统时的网 络接口的ip地址。通常是在与squid配置形成透明代理时使用，假设squid的监听端口是3128，我们可以通过以下语句来将来自 192.168.1.0/24，目的端口为80的数据包重定向到squid监听端口：
iptables -t nat -A PREROUTING -i eth1 -p tcp -s 192.168.1.0/24 --dport 80 -j REDIRECT --to-port 3128

首先，对防火墙接收到的目的ip为202.110.123.100和202.110.123.200的所有数据包进行目的NAT(DNAT):

iptables -A PREROUTING -i eth0 -d 202.110.123.100 -j DNAT --to 192.168.1.100
iptables -A PREROUTING -i eth0 -d 202.110.123.200 -j DNAT --to 192.168.1.200

其次，对防火墙接收到的源ip地址为192.168.1.100和192.168.1.200的数据包进行源NAT(SNAT):

iptables -A POSTROUTING -o eth0 -s 192.168.1.100 -j SNAT --to 202.110.123.100
iptables -A POSTROUTING -o eth0 -s 192.168.1.200 -j SNAT --to 202.110.123.200

这样，所有目的ip为202.110.123.100和202.110.123.200的数据包都将分别被转发给192.168.1.100和 192.168.1.200；而所有来自192.168.1.100和192.168.1.200的数据包都将分别被伪装成由 202.110.123.100和202.110.123.200，从而也就实现了ip映射。

--for   https://blog.csdn.net/xinyuan510214/article/details/51263001

##########################################################################

自动化监控系统——zabbix

监控服务器
	监控服务器可以通过SNMP或Agent采集数据
	数据可以写入MySQL、Oracle等数据库中
	服务器使用LNMP实现web前端的管理
被监控主机
	被监控主机需要安装Agent
	常见的网络设备一般支持SNMP（简单网络管理协议）

步骤一：部署监控服务器

1）安装LNMP环境
Zabbix监控管理控制台需要通过Web页面展示出来，并且还需要使用MySQL来存储数据，因此需要先为Zabbix准备基础LNMP环境。
[root@zabbixserver ~]# yum -y install gcc pcre-devel  openssl-devel
[root@zabbixserver ~]# tar -xf nginx-1.12.tar.gz
[root@zabbixserver ~]# cd nginx-1.12
[root@zabbixserver nginx-1.12]# ./configure --with-http_ssl_module

[root@zabbixserver nginx-1.12]# make && make install
[root@zabbixserver ~]# yum -y install php php-mysql \
> mariadb mariadb-devel mariadb-server
[root@zabbixserver ~]# yum -y  install  php-fpm-5.4.16-42.el7.x86_64.rpm
//注意，php-fpm这个软件包在lnmp_soft/目录下

2）修改Nginx配置文件
配置Nginx支持PHP动态网站，因为有大量PHP脚本需要执行，因此还需要开启Nginx的各种fastcgi缓存，加速PHP脚本的执行速度。
[root@zabbix server ~]# vim /usr/local/nginx/conf/nginx.conf
… …
http{
… …
    fastcgi_buffers 8 16k;                      //缓存php生成的页面内容，8个16k
    fastcgi_buffer_size 32k;                      //缓存php生产的头部信息
    fastcgi_connect_timeout 300;                 //连接PHP的超时时间
    fastcgi_send_timeout 300;                     //发送请求的超时时间
    fastcgi_read_timeout 300;                        //读取请求的超时时间
location ~ \.php$ {
                root           html;
                fastcgi_pass   127.0.0.1:9000;
                fastcgi_index  index.php;
                include        fastcgi.conf;
        }
… …

3）启动服务
启动Nginx、PHP-FPM、MariaDB服务，关闭SELinux与防火墙。
[root@zabbixserver ~]# systemctl start  mariadb
[root@zabbixserver ~]# systemctl start  php-fpm
[root@zabbixserver ~]# ln -s /usr/local/nginx/sbin/nginx /sbin/nginx
[root@zabbixserver ~]# nginx
[root@zabbixserver ~]# firewall-cmd --set-default-zone=trusted
[root@zabbixserver ~]# setenforce 0

步骤二：部署监控服务器Zabbix Server

1）源码安装Zabbix Server
多数源码包都是需要依赖包的，zabbix也一样，源码编译前需要先安装相关依赖包。
[root@zabbixserver lnmp_soft]# yum -y install  net-snmp-devel \
> curl-devel 
//安装相关依赖包
[root@zabbixserver lnmp_soft]# yum -y install  \
> libevent-devel-2.0.21-4.el7.x86_64.rpm
//注意libevent-devel这个软件包在lnmp_soft目录下有提供
[root@zabbixserver lnmp_soft]# tar -xf zabbix-3.4.4.tar.gz
[root@zabbixserver lnmp_soft]# cd zabbix-3.4.4/
[root@zabbixserver zabbix-3.4.4]# ./configure  --enable-server \
> --enable-proxy --enable-agent --with-mysql=/usr/bin/mysql_config \
> --with-net-snmp --with-libcurl
// --enable-server安装部署zabbix服务器端软件
// --enable-agent安装部署zabbix被监控端软件
// --enable-proxy安装部署zabbix代理相关软件
// --with-mysql配置mysql_config路径
// --with-net-snmp允许zabbix通过snmp协议监控其他设备
// --with-libcurl安装相关curl库文件，这样zabbix就可以通过curl连接http等服务，测试被监控主机服务的状态
[root@zabbix server zabbix-3.4.4]# make && make install

2）初始化Zabbix
创建数据库，上线Zabbix的Web页面
[root@zabbixserver ~]# mysql
mysql> create database zabbix character set utf8;
//创建数据库，支持中文字符集
mysql> grant all on zabbix.* to zabbix@'localhost' identified by 'zabbix';
//创建可以访问数据库的账户与密码
[root@zabbixserver ~]# cd lnmp_soft/zabbix-3.4.4/database/mysql/
[root@zabbixserver mysql]# mysql -uzabbix -pzabbix zabbix < schema.sql
[root@zabbixserver mysql]# mysql -uzabbix -pzabbix zabbix < images.sql
[root@zabbixserver mysql]# mysql -uzabbix -pzabbix zabbix < data.sql
//刚刚创建是空数据库，zabbix源码包目录下，有提前准备好的数据
//使用mysql导入这些数据即可（注意导入顺序）
上线Zabbix的Web页面
[root@zabbixserver ~]# cd lnmp_soft/zabbix-3.4.4/frontends/php/
[root@zabbixserver php]# cp -r * /usr/local/nginx/html/
[root@zabbixserver php]# chmod -R 777 /usr/local/nginx/html/*

修改Zabbix_server配置文件，设置数据库相关参数，启动Zabbix_server服务
[root@zabbixserver ~]# vim /usr/local/etc/zabbix_server.conf
DBHost=localhost
//数据库主机，默认该行被注释
DBName=zabbix
//设置数据库名称
DBUser=zabbix
//设置数据库账户
DBPassword=zabbix
//设置数据库密码，默认该行被注释
LogFile=/tmp/zabbix_server.log    
//设置日志，仅查看以下即可
[root@zabbixserver ~]# useradd -s /sbin/nologin Zabbix
//不创建用户无法启动服务
[root@zabbixserver ~]# zabbix_server                      //启动服务
[root@zabbixserver ~]# ss -ntulp |grep zabbix_server     //确认连接状态，端口10051
tcp LISTEN 0 128 *:10051 *:* users:(("zabbix_server",pid=23275,fd=4),("zabbix_server",pid=23274,fd=4)
提示：如果是因为配置文件不对，导致服务无法启动时，不要重复执行zabbix_server，
一定要先使用killall zabbix_server关闭服务后，再重新启动一次。
修改Zabbix_agent配置文件，启动Zabbix_agent服务
[root@zabbixserver ~]# vim /usr/local/etc/zabbix_agentd.conf
Server=127.0.0.1,192.168.2.5                    //允许哪些主机监控本机
ServerActive=127.0.0.1,192.168.2.5                //允许哪些主机通过主动模式监控本机
Hostname=zabbix_server                        //设置本机主机名
LogFile=/tmp/zabbix_server.log                    //设置日志文件
UnsafeUserParameters=1                        //是否允许自定义key
[root@zabbixserver ~]# zabbix_agentd            //启动监控agent
[root@zabbixserver ~]# ss -ntulp |grep zabbix_agentd   //查看端口信息为10050
tcp    LISTEN     0      128       *:10050                 *:*                   users:(("zabbix_agentd",pid=23505,fd=4),("zabbix_agentd",pid=23504,fd=4)
提示：如果是因为配置文件不对，导致服务无法启动时，不要重复执行zabbix_agentd，
一定要先使用killall zabbix_agentd关闭服务后，再重新启动一次。
浏览器访问Zabbix_server服务器的Web页面
[root@zabbixserver ~]# firefix http://192.168.2.5/index.php
//第一次访问，初始化PHP页面会检查计算机环境是否满足要求，如果不满足会给出修改建议
//默认会提示PHP的配置不满足环境要求，需要修改PHP配置文件

根据错误提示，修改PHP配置文件，满足Zabbix_server的Web环境要求
php-bcmath和php-mbstring都在lnmp_soft目录下有提供软件包。
[root@zabbixserver ~]# yum -y install  php-gd php-xml
[root@zabbixserver ~]# yum install php-bcmath-5.4.16-42.el7.x86_64.rpm  
[root@zabbixserver ~]# yum install php-mbstring-5.4.16-42.el7.x86_64.rpm
[root@zabbixserver ~]# vim /etc/php.ini
date.timezone = Asia/Shanghai                //设置时区
max_execution_time = 300                    //最大执行时间，秒
post_max_size = 32M                        //POST数据最大容量
max_input_time = 300                        //服务器接收数据的时间限制
memory_limit = 128M                        //内存容量限制
[root@zabbixserver ~]# systemctl restart php-fpm






















